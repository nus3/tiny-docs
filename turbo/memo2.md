## module bundler の作り方を読んでみて

https://hiroppy.me/blog/create-module-bundler-preparation

- エントリポイントから全てのモジュールを把握、ユニークな ID を発番
- コード内の`require`(ESM で言うところの`import`?)と発番した ID を置換する

### 全てのモジュールを把握

- エントリーポイントのコードを parse して AST に変換
- AST からファイル名を取得(`require`が使用されてる箇所を取得)
- `node_modules` のファイルを読み込む
  - この記事では一旦、node_modules 配下の package.json にある main からパッケージのエントリーポイントを取得
- 使用するモジュールをマッピング
  - 全てのファイル名を取得することでモジュールのコードを取得し、AST に変換し保持する
- すでに AST として保持してあるモジュールは再取得しないようにする(モジュールをキャッシュする)
- `require`の引数部分を ID に上書きする(保持してる AST からトラバースする)

### ランタイムコードの作成

- 即時実行関数を定義
- 即時実行関数の引数には ID とモジュールのコードが格納されている
- 即時実行関数内部ではモジュールのキャッシュを行いつつ、エントリーポイントから再帰的にモジュールのコードを取得し、実行する

## module bundler の作り方(ECMAScript Modules 編)

https://hiroppy.me/blog/create-module-bundler-esm

- ESM の場合、CJS の時とは異なり、require の中身を moduleID に変換する前に、ソースコードをトラバースし、import から require へ変換

## 雑メモ

- parse(コードから AST を生成)→traverse(AST ノードの操作)→generate(AST からコードの生成)
- require の id のみを変換してるが、バンドル後のコードを見ると require 自体は自前で定義した関数
  - ESM 対応の際も基本的には使用されている全てのモジュールを一つにまとめ、各々の依存関係を ID でマッピングし、それを実行できる関数(`(function (module, exports, require){})`の`require`引数のような)があれば良い？

## 読んでみてのざっくりとしたイメージ

1. エントリーポイントのコードをパースして AST に変換
2. AST から依存しているモジュールをパス(ファイル名)を取得
3. 依存している全てのモジュールのコードをパースして AST に変換
4. ID と変換した AST をマッピング
5. `require`や`import`部分をトラバースし、内容をマッピングした ID に変換。
6. トラバースした AST をコードに変換
7. `{id: 変換後のコード}`の形式でオブジェクトを生成
8. エントリーポイントのコードから再帰的に変換後のコードを実行する
   1. その際に、`require`や`import`の部分を実行するコードでは再帰的に扱えるようにする
